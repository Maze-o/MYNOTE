<h1>JAVA</h1>

Programming Language : JAVA
Pro(앞으로, 미리) gram(쓰다) : 앞으로 할 일들을 미리 적어놓는 작업

<hr>

<h2>음수, 진수</h2>

```
함 수(data) : 수를 담아 특정 처리를 하는 논리적 공간

data 수 : 저장, 처리 로 나뉜다
저장에서 숫자형과 문자형으로 나누고
숫자형에는 정수 (양수 -> 10진수, 음수) , 실수 ()

컴퓨터(CPU)는 가산회로에 의해 가산작업(덧셈처리)를 할 수 있음 (뺄셈처리 불가능) // 컴퓨터는 음수를 저장할 수 없음
- 실제로 뺄셈의 결과를 가져오는 이유는 보수개념을 도입했기 떄문
보수개념 ex ) 7-4 = 3 에서 4 에서 얼마나 더해야지 10이 나오는지를 계산해서 (6) 7 + 6을 한 후에 13이 나오면 앞자리를 버리는 방식으로 계산

1byte 공간에서 
+96 = 01100000
-96 = 10100000(맨 앞에 1이 들어간 순간 음수) // 0과 1을 뒤집은 후 +1 해줌 ex ) 01100000 - > 10011111 + 1 = 10100000
```

<hr>

<h2>변수, 상수, 자료형</h2>

```
수 (data) : 선 저장 / 후 처리
변수 : 개발자의 유지보수 측면에서 바뀔 가능성이 있는 수
변수명 : 저장되어져 있는 변수 공간에 접근하기 위한 문자형태의 주소
자료형 : 수(data)를 저장하고 데이터의 유형을 제한하기 위해 사용되는 예약어

int n1; // 4byte 정수만 저장할 공간 형성 -> n1 이름 부여 변수 정의 
n1 =  10; // 10 리터럴상수값을 상수Poll 공간에 저장한 후 n1공간에 대입

자료형 -

정수 - 
1. byte - 1byte // 8bit => -128 ~ 127
2. short - 2byte // 16bit => -32768 ~ 32767 
3. char - 2byte (음수가 들어갈 수 없는 자료형) // 16bit => 0 ~ 65535
4. int - 4byte (기본자료형) // 32bit => +- 21억 
5. long - 8byte // 64bit => 많다

실수 - 지수, 가수부 (안쓰는게 좋다)
1. float - 4byte 실수(6~9자리)
2. double  - 8byte 실수(15~18자리) (기본자료형)

문자 -
1. 단일문자 : char
2. 문자열 : String

논리 -
1. boolean : 1byte 

```

<hr>

<h2>형변환</h2>

```
(자료형)형변환 - 데이터 손실을 최소하 하기 위해서 함
연산작업시(=, +, -) 일치하지 않는 자료형을 일치시키는 작업

자동형변환 (암시적 형변환) - 컴파일러에 의해 자동으로 변환
ex) byte byteValue = 10; 
		int intValue = byteValue; // byte형이 int형에 값을 대입할 때 int형의 데이터 크기가 더 크기때문에 자동으로 형변환 해줌
     보이지 않지만 (int)가 byteValue앞에 들어가 있음

강제형변환 (명시적 형변환) - 프로그래머에 의해 강제로 변환
ex) int intValue = 44032; 
		char charValue = (char) intValue; // int형이 char형에 값을 대입하려면 데이터 공간이 더 작기 때문에 강제로 변환해줘야 함

자동 형변환일 경우 데이터 손실을 최소화 하는 방향으로 자료형이 일치
byte < short,char < int < long < float < double

문자열 형변환 - String
정수,실수형으로 변환할떄는 Integer.parseInt 사용


```

<hr>

<h2>분기문</h2>

```
if  -
if (조건식) {실행문} // 조건식 안에서 연산처리 가능
else if (조건식) {실행문} // if 다음에 오는 분기처리
else {실행문} // 위에 모든 if문에 걸리지 않으면 실행

switch (입력변수) { 실행문 } // 입력변수의 값을 case에 대입 시켜서 처리 (case에 true가 되지 않으면 default실행)
실행문 - case : 변수값 {실행문} // break 쓰지 않으면 탈출이 안돼서 모두 실행함
	default : case에 걸리지 않을 시 실행 


```

<hr>


<h2>반복문</h2> 

```
반복문은 무한으로 실행시킬 것이 아니라면 탈출하기 위한 조건을 만들어 줘야함
While -
WHile (조건식) { 조건식이 참인 경우 실행되는 종속 문장 (1개일 때는 생략 가능) }

for -
for (탈출용 변수; 탈출을 위한 조건식; 탈출을 위한 연산식;) { 실행 문장 }


```

<hr>


<h2>객체지향</h2>

정리 - 
1. 객체일반
	- 객체란 / 객체구조 / 객체지향언어 / 클래스란 / 메모리
	- 함수오버로딩 / 생성자오버로딩
	- 정보은닉 (private / getter and setter) / 갭슐화
	- 배열 (primitive / reference) 배열
	- static

2. 상속
	- 상속일반 / 상속사용이유 / 상속기본코드 (extends)
	- 오버라이딩 ( vs 오버로딩)
	- Up / downCasting
	- 추상클래스(사용이유)
	- 인터페이스(사용이유)

객체 - !존재! 하는 사물
      배타적이고 독립적인 공간을 차지
      
```

객체 구조 -
속성 (Attribute) : 객체만의 고유한 data, 멤버변수, 필드
기능 (Function) :  메서드(method), 함수(function), 행위(behavior)
클래스명 변수명; // 클래스의 객체를 참조하기 위한 참조변수를 선언
변수명 = new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장

new 연산자 - 인스턴스(객체)를 생성해주는 역할, 메모리(Heap 영역)에 데이터를 저장할 공간을 할당받고 그 공간의 참조값을 객체에게 반환하여 주고 이어서 생성자를 호출
클래스 변수 = new 클래스();

메서드 - 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것
반환타입 메서드 이름(타입 변수명, 타입 변수명, ...)
선언부 {메서드 호출 시 수행될 코드 // 구현부}

생성자 -
인스턴트가 생성될 때 호출되는 인스턴스 초기화 메서드 (연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다)
모든 클래스에는 반드시 하나 이상의 생성자가 정의되어 있어야 함 (생성자가 정의되어 있지 않을 경우, 컴파일러가 기본생성자를 생성)

매개변수가 있는 생성자 - 생성자도 메소드 처럼 매개변수를 선언하여 호출 시 값을 넘겨 받아서 인스턴스 초기화 작업에 사용될 수 있음

this - 객체, 자기 자신을 의미
1. 클래스의 속성과 생성자/ 메소드의 매개변수의 이름이 같은 경우
2. 클래스에 오버로딩된 다른 생성자 호출
3. 객체 자신의 참조값을 전달하고 싶을 때

메소드 오버로딩 - 같은 이름의 메소드를 중복하여 정의하는 것을 의미
자바는 원래 한 클래스 내에 같은 이름의 메소드를 둘 이상 가질 수 없음 , 하지만 매개변수의 개수나 타입을 다르게 하면 하나의 이름으로 메소드를 작성할 수 있음
ex )  void display(int num1)              
      void display(int num1, String str1)   // display()메소드를 호출하면 컴파일러가 자동으로 같은 시그니처(메서드 명과 파라미터의 순서, 타입, 개수)를 가지는 메서드를 찾아 호출



static - static으로 선언 시 가장 먼저 객체가 생성됨



```

<hr>

<h2>상속</h2>

상속 - 상위클래스 (부모, super)의 속성과 기능을 하위클래스 (자식, Sub)가 그대로 받아서 사용할 수 있도록 허용된 문법
```
상속을 사용하는 이유 - 
1. 코드의 중복 방지 (가독성 향상)
2. 유지보수 
3. 확장성

super() - 상속관계의 상위클래스의 생성자를 호출

method overrding (함수 재정의) -
상속관계를 전재로 상위클래스의 메서드를 하위클래스가 재정의(고쳐서 사용) 하는 것을 허용한 문법
메서드의 헤더부분은 동일하게 두고 본체({})의 로직을 다양하게 둠으로써(다형성) 같은 함수를 상위클래스로부터 물려받더라도 각 하위클래스마다 다양한 형태의 결과물을 만들어낼 수 있다.

오버로딩과 오버라이딩의 차이 - 면접에잘나온대요!!~~
오버로딩 :
1. 파라미터
2. 개발자의 편의성에 중점
3. 상속전제 x
	
오버라이딩 : 
1. 상속받은 메소드를 재정의
2. 다양성
3. 상속전제 o

UpCasting - 상위클래스형의 참조변수 = 하위클래스형의 객체 (자동형변환)
            상속관계의 모든 클래스로 만든 객체를 연결할 수 있다
	    upcasting 상태에서는 확장된(추가된) 멤버변수, 멤버함수에 접근이 불가능함 (downcasting으로 해결)
            upcasting 상태에서는 재정의된 함수에 접근 가능하다

DownCasting - 하위클래스형 참조변수  = 상위클래스형 객체 (강제형변환)
	      UPcasting을 전제로 확장된(추가된) 멤버에 접근하기 위해 사용

추상클래스 - 추상 메서드를 하나 이상 정의하고 있는 클래스 (abstract 로 정의)
            함수 이름을 통일하기 위한 강제성
	    설계 단계에서 구현을 나중에 하기 위해 사용
            재정의를 해야 객체를 만들수 있음

interface - 속성 : public static final
            함수 : 추상메서드 (재정의를 무조건 해야함)
            결합도를 낮추기 위함
            다중 상속 가능 (implements)
	    

```









